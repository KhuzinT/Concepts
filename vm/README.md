# Виртуальная машина

Виртуальная машина на основе стека

Состоит из:

* **stack** &nbsp; стековая память
* **local** &nbsp; &nbsp;буффер для хранения локальных переменных
* **ip** &nbsp; &nbsp;instruction pointer &nbsp; адрес выполняемой функции
* **sp** &nbsp; stack pointer &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; указатель на вершину стека
* **fp** &nbsp; &nbsp;frame poiner &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; позиция, относительно которой отсчитываются локальные переменные

# Байт-код

### Арифметические операции 

Вместо двух верхних элементов стека кладется результат арифметической операции над ними

* **ADD** &nbsp; плюс
* **SUB** &nbsp; минус
* **MUL** &nbsp; умножить
* **DIV** &nbsp; &nbsp; целочисленное деление
* **MOD** &nbsp; остаток от деления

### Условные выражения

Вместо двух верхних элементов стека кладется результат логической операции над ними (1 или 0)

* **EQ** &nbsp; равно
* **NE** &nbsp; не равно
* **LT** &nbsp; &nbsp;меньше
* **LE** &nbsp; &nbsp;меньше или равно
* **GT** &nbsp; &nbsp;больше
* **GE** &nbsp; &nbsp;больше или равно

### Условные конструкции

* **JMP** &nbsp; поменять адрес **ip** на следующее число в коде
* **JMPT** &nbsp; поменять адрес **ip** на следующее число в коде, если на вершине стека 1
* **JMPF** &nbsp; поменять адрес **ip** на следующее число в коде, если на вершине стека 0

### Операции со стеком

* **PUSH** &nbsp; положить на вершину стека следующее число в коде
* **POP** &nbsp; &nbsp;  удалить элемент с вершины стека

### Управление памятью

* **LOAD** &nbsp; &nbsp; из кода получает **offset** локальных переменных в стеке, затем сохраняет на стеке переменную по адресу **fp + offset**
* **STORE** &nbsp; из кода получает **offset**, затем сохраняет в **local** элемент с вершины стека


* **GLOAD** &nbsp; &nbsp; получает **local**-адрес элемента с вершины стека и перекладывает элемент на стек
* **GSTORE** &nbsp; кладет элемент со стека в **local**, по адресу, который передается в коде

### Вызов процедур

* **CALL** &nbsp; вызывает функцию: после команды в коде должен идти адрес функции и кол-во аргументов, которое нужно взять со стека
* **RET** &nbsp; &nbsp; возвращает элемент с вершины стека из функции

### Ввод-вывод

* **READ** &nbsp;&nbsp; &nbsp; &nbsp; положить введенное число на вершину стека
* **WRITE** &nbsp; &nbsp; &nbsp; напечатать число на вершине стека
* **HELLO** &nbsp; &nbsp; &nbsp;напечатать Hello world!
* **STR** &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; выводит строку на экран: следующим числом в коде должно идти **n** - кол-во символов в строке, следующие **n** чисел - код символа (должен помещаться в **char**)

### Выход

* **EXIT** &nbsp; остановить программу

## Особенности реализации

* При создании экземпляра виртуальной машины можно указать размеры **stack** и **local**
* Для выполнения есть метод exec: код можно передать как вектор int-ов (смотри пример с Фибоначчи в main), также на вход принимается entrypoint - начальное значение для **ip**
* Для запуска достаточно выполнить run.sh

## Источники вдохновения

[Пишем регистровую машину](https://freecx.github.io/blog/2019/08/29/simple-register-vm)

[Интерпретаторы байт-кодов](https://habr.com/ru/companies/badoo/articles/425325/)

[Разработка стековой виртуальной машины](https://habr.com/ru/articles/560356/)

[Simple Virtual Machine](https://www.bartoszsypytkowski.com/simple-virtual-machine/)

[Write you Own Virtual Machine](https://www.jmeiners.com/lc3-vm/)

[Writing a simple vm](https://www.andreinc.net/2021/12/01/writing-a-simple-vm-in-less-than-125-lines-of-c)

